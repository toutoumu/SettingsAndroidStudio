<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="382" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Typography" />
      <item value="systemuicontroller" />
      <item value="accompanist" />
      <item value="Surface" />
      <item value="When [LaunchedEffect] enters the composition it will launch [block] into the composition's [CoroutineContext]. The coroutine will be [cancelled][Job.cancel] and re-launched when [LaunchedEffect] is recomposed with a different [key1]. The coroutine will be [cancelled][Job.cancel] when the [LaunchedEffect] leaves the composition. This function should not be used to (re-)launch ongoing tasks in response to callback events by way of storing callback data in [MutableState] passed to [key1]. Instead, see [rememberCoroutineScope] to obtain a [CoroutineScope] that may be used to launch ongoing jobs scoped to the composition in response to event callbacks." />
      <item value="Add semantics keyvalue pairs to the layout node, for use in testing, accessibility, etc. The provided lambda receiver scope provides &quot;key = value&quot;-style setters for any [SemanticsPropertyKey]. Additionally, chaining multiple semantics modifiers is also a supported style. The resulting semantics produce two [SemanticsNode] trees: The &quot;unmerged tree&quot; rooted at [SemanticsOwner.unmergedRootSemanticsNode] has one [SemanticsNode] per layout node which has any [SemanticsModifier] on it. This [SemanticsNode] contains all the properties set in all the [SemanticsModifier]s on that node. The &quot;merged tree&quot; rooted at [SemanticsOwner.rootSemanticsNode] has equal-or-fewer nodes: it simplifies the structure based on [mergeDescendants] and [clearAndSetSemantics]. For most purposes (especially accessibility, or the testing of accessibility), the merged semantics tree should be used. @param mergeDescendants Whether the semantic information provided by the owning component and its descendants should be treated as one logical entity. Most commonly set on screen-reader-focusable items such as buttons or form fields. In the merged semantics tree, all descendant nodes (except those themselves marked [mergeDescendants]) will disappear from the tree, and their properties will get merged into the parent's configuration (using a merging algorithm that varies based on the type of property -- for example, text properties will get concatenated, separated by commas). In the unmerged semantics tree, the node is simply marked with [SemanticsConfiguration.isMergingSemanticsOfDescendants]. @param properties properties to add to the semantics. [SemanticsPropertyReceiver] will be provided in the scope to allow access for common properties and its values." />
      <item value="Make the emoji selector focusable so it can steal focus from TextField" />
      <item value="Provide WindowInsets to our content. We don't want to consume them, so that they keep being pass down the view hierarchy (since we're using fragments)." />
      <item value="Launched Effect" />
      <item value="semantics" />
      <item value="Request focus to force the TextField to lose it If the selector is shown, always request focus to trigger a TextField.onFocusChange." />
      <item value="Declare the preferred height of the content to match the height of the navigation bars when present at the bottom of the screen. This is very handy when used with `Spacer` to push content below the navigation bars: ``` Column { Content to be drawn above status bars (y-axis) Spacer(Modifier.navigationBarHeight()) } ``` It's also useful when used to draw a scrim which matches the navigation bars: ``` Spacer( Modifier.navigationBarHeight() .fillMaxWidth() .drawBackground(MaterialTheme.colors.background.copy(alpha = 0.3f) ) ``` Internally this matches the behavior of the [Modifier.height] modifier." />
      <item value="Apply additional space which matches the height of the status bars height along the top edge of the content." />
      <item value="velocity" />
      <item value="shrink Towards" />
      <item value="Tween Spec" />
      <item value="duration Millis" />
      <item value="PROVICE" />
      <item value="Lots" />
      <item value="Prking Item" />
      <item value="隐私政策" />
      <item value="Combines cells with adaptive number of rows or columns. It will try to position as many rows or columns as possible on the condition that every cell has at least [minSize] space and all extra space distributed evenly. For example, for the vertical [LazyVerticalGrid] Adaptive(20.dp) would mean that there will be as many columns as possible and every column will be at least 20.dp and all the columns will have equal width. If the screen is 88.dp wide then there will be 4 columns 22.dp each." />
      <item value="An effect for handling presses of the system back button. Calling this in your composable adds the given lambda to the [OnBackPressedDispatcher] of the [LocalOnBackPressedDispatcherOwner]. If this is called by nested composables, if enabled, the inner most composable will consume the call to system back and invoke its lambda. The call will continue to propagate up until it finds an enabled BackHandler. @sample androidx.activity.compose.samples.BackHandler @param enabled if this BackHandler should be enabled @param onBack the action invoked by pressing the system back" />
      <item value="Caches the [PagingData] such that any downstream collection from this flow will share the same [PagingData]. The flow is kept active as long as the given [scope] is active. To avoid leaks, make sure to use a [scope] that is already managed (like a ViewModel scope) or manually cancel it when you don't need paging anymore. A common use case for this caching is to cache [PagingData] in a ViewModel. This can ensure that, upon configuration change (e.g. rotation), then new Activity will receive the existing data immediately rather than fetching it from scratch. Calling [cachedIn] is required to allow calling [submitData][androidx.paging.AsyncPagingDataAdapter] on the same instance of [PagingData] emitted by [Pager] or any of its transformed derivatives, as reloading data from scratch on the same generation of [PagingData] is an unsupported operation. Note that this does not turn the `Flow&lt;PagingData&gt;` into a hot stream. It won't execute any unnecessary code unless it is being collected." />
      <item value="repository" />
      <item value="coroutine" />
      <item value="Onboarding" />
      <item value="Tell Compose runtime that this object will not change so it can perform optimizations" />
      <item value="This app draws behind the system bars, so we want to handle fitting system windows" />
      <item value="expect" />
      <item value="用户协议" />
      <item value="Remember the value produced by [init]. It behaves similarly to [remember], but the stored value will survive the activity or process recreation using the saved instance state mechanism (for example it happens when the screen is rotated in the Android application). @sample androidx.compose.runtime.saveable.samples.RememberSaveable If you use it with types which can be stored inside the Bundle then it will be saved and restored automatically using [autoSaver], otherwise you will need to provide a custom [Saver] implementation via the [saver] param. @sample androidx.compose.runtime.saveable.samples.RememberSaveableCustomSaver You can use it with a value stored inside [androidx.compose.runtime.mutableStateOf]. @sample androidx.compose.runtime.saveable.samples.RememberSaveableWithMutableState If the value inside the MutableState can be stored inside the Bundle it would be saved and restored automatically, otherwise you will need to provide a custom [Saver] implementation via an overload with which has `stateSaver` param. @sample androidx.compose.runtime.saveable.samples.RememberSaveableWithMutableStateAndCustomSaver @param inputs A set of inputs such that, when any of them have changed, will cause the state to reset and [init] to be rerun @param saver The [Saver] object which defines how the state is saved and restored. @param key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree @param init A factory function to create the initial value of this state" />
      <item value="Snapshot" />
      <item value="Return a new [MutableState] initialized with the passed in [value] The MutableState class is a single value holder whose reads and writes are observed by Compose. Additionally, writes to it are transacted as part of the [Snapshot] system. @param value the initial value for the [MutableState] @param policy a policy to controls how changes are handled in mutable snapshots." />
      <item value="enable Placeholders" />
      <item value="UNSPLASH STARTING PAGE INDEX" />
      <item value="Add content padding so that the content can be scrolled (y-axis) below the status bar + app bar" />
      <item value="reverse Layout" />
      <item value="Use statusBarsPadding() to move the app bar content below the status bar" />
      <item value="Use navigationBarsWithImePadding(), to move the input panel above both the navigation bar, and on-screen keyboard (IME)" />
      <item value="SemanticsPropertyReceiver is the scope provided by semantics {} blocks, letting you set keyvalue pairs primarily via extension functions." />
      <item value="keyboard Shown Property" />
      <item value="content Description" />
      <item value="[CompositionLocalProvider] binds values to [ProvidableCompositionLocal] keys. Reading the [CompositionLocal] using [CompositionLocal.current] will return the value provided in [CompositionLocalProvider]'s [values] parameter for all composable functions called directly or indirectly in the [content] lambda." />
      <item value="annotation" />
      <item value="Mutable Transition State" />
      <item value="Opt-in to experiment animated insets support" />
      <item value="Composition Local Provider" />
      <item value="Create a ViewWindowInsetObserver using this view, and call start() to start listening now. The WindowInsets instance is returned, allowing us to provide it to AmbientWindowInsets in our content below." />
      <item value="Circular Reveal" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="907" />
        <entry key="ENGLISH" value="908" />
        <entry key="ESTONIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="4" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1630978642775" />
  </component>
</application>