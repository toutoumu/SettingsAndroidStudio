<application>
  <component name="AppStorage">
    <option name="newTranslationDialogHeight" value="387" />
    <option name="newTranslationDialogWidth" value="835" />
    <option name="newTranslationDialogX" value="331" />
    <option name="newTranslationDialogY" value="245" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="m Transform Start" />
      <item value="Overrides the {@link com.bumptech.glide.request.target.Target}'s width and height with the given values. This is useful for thumbnails, and should only be used for other cases when you need a very specific image size. @param width The width in pixels to use to load the resource. @param height The height in pixels to use to load the resource. @return This request builder." />
      <item value="Navigate to a destination via the given deep link {@link Uri}. {@link NavDestinationhasDeepLink(Uri)} should be called on {@link getGraph() the navigation graph} prior to calling this method to check if the deep link is valid. If an invalid deep link is given, an {@link IllegalArgumentException} will be thrown. @param deepLink deepLink to the destination reachable from the current NavGraph @param navOptions special options for this navigation operation @param navigatorExtras extras to pass to the Navigator @see navigate(NavDeepLinkRequest, NavOptions, Navigator.Extras)" />
      <item value="Navigate to a destination via the given deep link {@link Uri}. {@link NavDestinationhasDeepLink(Uri)} should be called on {@link getGraph() the navigation graph} prior to calling this method to check if the deep link is valid. If an invalid deep link is given, an {@link IllegalArgumentException} will be thrown." />
      <item value="factor Degree to which the animation should be eased. Setting factor to 1.0f produces an upside-down y=x^2 parabola. Increasing factor above 1.0f exaggerates the ease-out effect (i.e., it starts even faster and ends evens slower)." />
      <item value="ceil" />
      <item value="pop Up To Inclusive" />
      <item value="navigation" />
      <item value="This method is called whenever the user chooses to navigate Up within your application's activity hierarchy from the action bar. &lt;p&gt;If a parent was specified in the manifest for this activity or an activity-alias to it, default Up navigation will be handled automatically. See {@link getSupportParentActivityIntent()} for how to specify the parent. If any activity along the parent chain requires extra Intent arguments, the Activity subclass should override the method {@link onPrepareSupportNavigateUpTaskStack(androidx.core.app.TaskStackBuilder)} to supply those arguments.&lt;p&gt; &lt;p&gt;See &lt;a href=&quot;{@docRoot}guidetopicsfundamentalstasks-and-back-stack.html&quot;&gt;Tasks and Back Stack&lt;a&gt; from the developer guide and &lt;a href=&quot;{@docRoot}designpatternsnavigation.html&quot;&gt;Navigation&lt;a&gt; from the design guide for more information about navigating within your app.&lt;p&gt;" />
      <item value="destination" />
      <item value="Using it has no effect, and the AndroidGradle plugin optimizes dexing automatically." />
      <item value="incremental" />
      <item value="Using insecure protocols with repositories, without explicit opt-in, is unsupported. Switch Maven repository 'maven2(http:repo.pageturner-reader.org)' to redirect to a secure protocol (like HTTPS) or allow insecure protocols. See https:docs.gradle.org7.0.2dslorg.gradle.api.artifacts.repositories.UrlArtifactRepository.htmlorg.gradle.api.artifacts.repositories.UrlArtifactRepository:allowInsecureProtocol for more details." />
      <item value="A singleton which can be used to bind the lifecycle of cameras to any {@link LifecycleOwner} within an application's process. &lt;p&gt;Only a single process camera provider can exist within a process, and it can be retrieved with {@link getInstance(Context)}. &lt;p&gt;Heavyweight resources, such as open and running camera devices, will be scoped to the lifecycle provided to {@link bindToLifecycle(LifecycleOwner, CameraSelector, UseCase...)}. Other lightweight resources, such as static camera characteristics, may be retrieved and cached upon first retrieval of this provider with {@link getInstance(Context)}, and will persist for the lifetime of the process. &lt;p&gt;This is the standard provider for applications to use." />
      <item value="LENS FACING FRONT" />
      <item value="is Reversed Horizontal" />
      <item value="format" />
      <item value="In the background, load latest photo taken (if any) for gallery thumbnail" />
      <item value="Remove previous UI if any" />
      <item value="Wait for the views to be properly laid out" />
      <item value="performance" />
      <item value="compatible" />
      <item value="implementation Mode" />
      <item value="USE FRAME PROCESSOR" />
      <item value="exposure Correction" />
      <item value="filter Control 1" />
      <item value="take Picture Snapshot" />
      <item value="camera Experimental" />
      <item value="Sets the image capture mode. &lt;p&gt;Valid capture modes are {@link CaptureModeCAPTURE_MODE_MINIMIZE_LATENCY}, which prioritizes latency over image quality, or {@link CaptureModeCAPTURE_MODE_MAXIMIZE_QUALITY}, which prioritizes image quality over latency. &lt;p&gt;If not set, the capture mode will default to {@link CaptureModeCAPTURE_MODE_MINIMIZE_LATENCY}. @param captureMode The requested image capture mode. @return The current Builder." />
      <item value="Create a SurfaceSizeDefinition object with input analysis, preview, record and maximum sizes" />
      <item value="get Analysis Size" />
      <item value="Transform to a SurfaceConfig object with image format and size info @param imageFormat the image format info for the surface configuration object @param size the size info for the surface configuration object @retur" />
      <item value="Compare with surface size definition to determine the surface configuration size" />
      <item value="exclude Problematic Sizes" />
      <item value="ImageFormat.PRIVATE is only public after Android level 23. Therefore, using SurfaceTexture.class to get the supported output sizes before Android level 23." />
      <item value="SCALER STREAM CONFIGURATION MAP" />
      <item value="OPTION ROTATION" />
      <item value="Simulate a button click, including a small delay while it is being pressed to trigger the appropriate animations." />
      <item value="Restrict To" />
      <item value="Sets the intended output target resolution. &lt;p&gt;The target resolution attempts to establish a minimum bound for the image resolution. The actual image resolution will be the closest available resolution in size that is not smaller than the target resolution, as determined by the Camera implementation. However, if no resolution exists that is equal to or larger than the target resolution, the nearest available resolution smaller than the target resolution will be chosen. Resolutions with the same aspect ratio of the provided {@link Size} will be considered in higher priority before resolutions of different aspect ratios. &lt;p&gt;It is not allowed to set both target aspect ratio and target resolution on the same use case. Attempting so will throw an IllegalArgumentException when building the Config. &lt;p&gt;The resolution {@link Size} should be expressed in the coordinate frame after rotating the supported sizes by the target rotation. For example, a device with portrait natural orientation in natural target rotation requesting a portrait image may specify 480x640, and the same device, rotated 90 degrees and targeting landscape orientation may specify 640x480. &lt;p&gt;When the target resolution is set, {@link ImageCapturesetCropAspectRatio(Rational)} will be automatically called to set corresponding value. Such that the output image will be cropped into the desired aspect ratio. &lt;p&gt;The maximum available resolution that could be selected for an {@link ImageCapture} will depend on the camera device's capability. &lt;p&gt;If not set, the largest available resolution will be selected to use. Usually, users will intend to get the largest still image that the camera device can support. @param resolution The target resolution to choose from supported output sizes list. @return The current Builder." />
      <item value="CAPTURE MODE MAXIMIZE QUALITY" />
      <item value="CAPTURE MODE MINIMIZE LATENCY" />
      <item value="Directions" />
      <item value="Update session configuration and possibly reconfigure session." />
      <item value="Sets the desired rotation of the output image. &lt;p&gt;This will affect the EXIF rotation metadata in images saved by takePicture calls and the {@link ImageInfogetRotationDegrees()} value of the {@link ImageProxy} returned by {@link OnImageCapturedCallback}. These will be set to be the rotation, which if applied to the output image data, will make the image match target rotation specified here. &lt;p&gt;While rotation can also be set via {@link BuildersetTargetRotation(int)}, using {@link ImageCapturesetTargetRotation(int)} allows the target rotation to be set dynamically. &lt;p&gt;In general, it is best to use an {@link android.view.OrientationEventListener} to set the target rotation. This way, the rotation output will indicate which way is down for a given image. This is important since display orientation may be locked by device default, user setting, or app configuration, and some devices may not transition to a reverse-portrait display orientation. In these cases, use {@link ImageCapturesetTargetRotation} to set target rotation dynamically according to the {@link android.view.OrientationEventListener}, without re-creating the use case. Note the OrientationEventListener output of degrees in the range [0..359] should be converted to a surface rotation. The mapping values are listed as the following. &lt;p&gt;{@link android.view.OrientationEventListenerORIENTATION_UNKNOWN}: orientation == -1 &lt;p&gt;{@link SurfaceROTATION_0}: orientation &gt;= 315 || orientation &lt; 45 &lt;p&gt;{@link SurfaceROTATION_90}: orientation &gt;= 225 &amp;&amp; orientation &lt; 315 &lt;p&gt;{@link SurfaceROTATION_180}: orientation &gt;= 135 &amp;&amp; orientation &lt; 225 &lt;p&gt;{@link SurfaceROTATION_270}: orientation &gt;= 45 &amp;&amp; orientation &lt; 135 &lt;p&gt;When this function is called, value set by {@link ImageCapture.BuildersetTargetResolution(Size)} will be updated automatically to make sure the suitable resolution can be selected when the use case is bound. Value set by {@link ImageCapturesetCropAspectRatio(Rational)} will also be updated automatically to make sure the output image is cropped into expected aspect ratio. &lt;p&gt;If no target rotation is set by the application, it is set to the value of {@link DisplaygetRotation()} of the default display at the time the use case is created. The use case is fully created once it has been attached to a camera. &lt;p&gt;takePicture uses the target rotation at the time it begins executing (which may be delayed waiting on a previous takePicture call to complete). @param rotation Target rotation of the output image, expressed as one of {@link SurfaceROTATION_0}, {@link SurfaceROTATION_90}, {@link SurfaceROTATION_180}, or {@link SurfaceROTATION_270}." />
      <item value="Sets the desired rotation of the output image. &lt;p&gt;This will affect the EXIF rotation metadata in images saved by takePicture calls and the {@link ImageInfogetRotationDegrees()} value of the {@link ImageProxy} returned by {@link OnImageCapturedCallback}. These will be set to be the rotation, which if applied to the output image data, will make the image match target rotation specified here. &lt;p&gt;While rotation can also be set via {@link BuildersetTargetRotation(int)}, using {@link ImageCapturesetTargetRotation(int)} allows the target rotation to be set dynamically. &lt;p&gt;In general, it is best to use an {@link android.view.OrientationEventListener} to set the target rotation. This way, the rotation output will indicate which way is down for a given image. This is important since display orientation may be locked by device default, user setting, or app configuration, and some devices may not transition to a reverse-portrait display orientation. In these cases, use {@link ImageCapturesetTargetRotation} to set target rotation dynamically according to the {@link android.view.OrientationEventListener}, without re-creating the use case. Note the OrientationEventListener output of degrees in the range [0..359] should be converted to a surface rotation. The mapping values are listed as the following. &lt;p&gt;{@link android.view.OrientationEventListenerORIENTATION_UNKNOWN}: orientation == -1 &lt;p&gt;{@link SurfaceROTATION_0}: orientation &gt;= 315 || orientation &lt; 45 &lt;p&gt;{@link SurfaceROTATION_90}: orientation &gt;= 225 &amp;&amp; orientation &lt; 315 &lt;p&gt;{@link SurfaceROTATION_180}: orientation &gt;= 135 &amp;&amp; orientation &lt; 225 &lt;p&gt;{@link SurfaceROTATION_270}: orientation &gt;= 45 &amp;&amp; orientation &lt; 135 &lt;p&gt;When this function is called, value set by {@link ImageCapture.BuildersetTargetResolution(Size)} will be updated automatically to make sure the suitable resolution can be selected when the use case is bound. Value set by {@link ImageCapturesetCropAspectRatio(Rational)} will also be updated automatically to make sure the output image is cropped into expected aspect ratio. &lt;p&gt;If no target rotation is set by the application, it is set to the value of {@link DisplaygetRotation()} of the default display at the time the use case is created. The use case is fully created once it has been attached to a camera. &lt;p&gt;takePicture uses the target rotation at the time it begins executing (which may be delayed waiting on a previous takePicture call to complete)." />
      <item value="&lt;p&gt;The orientation for a JPEG image.&lt;p&gt; &lt;p&gt;The clockwise rotation angle in degrees, relative to the orientation to the camera, that the JPEG picture needs to be rotated by, to be viewed upright.&lt;p&gt; &lt;p&gt;Camera devices may either encode this value into the JPEG EXIF header, or rotate the image data to match this orientation. When the image data is rotated, the thumbnail data will also be rotated.&lt;p&gt; &lt;p&gt;Note that this orientation is relative to the orientation of the camera sensor, given by {@link CameraCharacteristicsSENSOR_ORIENTATION android.sensor.orientation}.&lt;p&gt; &lt;p&gt;To translate from the device orientation given by the Android sensor APIs for camera sensors which are not EXTERNAL, the following sample code may be used:&lt;p&gt; &lt;pre&gt;&lt;code&gt;private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) { if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0; int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION); Round device orientation to a multiple of 90 deviceOrientation = (deviceOrientation + 45) 90 90; Reverse device orientation for front-facing cameras boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT; if (facingFront) deviceOrientation = -deviceOrientation; Calculate desired JPEG orientation relative to camera orientation to make the image upright relative to the device orientation int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360; return jpegOrientation; } &lt;code&gt;&lt;pre&gt; &lt;p&gt;For EXTERNAL cameras the sensor orientation will always be set to 0 and the facing will also be set to EXTERNAL. The above code is not relevant in such case.&lt;p&gt; &lt;p&gt;This tag is also used to describe the orientation of the HEIC image capture, in which case the rotation is reflected by {@link android.media.ExifInterfaceTAG_ORIENTATION EXIF orientation flag}, and not by rotating the image data itself.&lt;p&gt; &lt;p&gt;&lt;b&gt;Units&lt;b&gt;: Degrees in multiples of 90&lt;p&gt; &lt;p&gt;&lt;b&gt;Range of valid values:&lt;b&gt;&lt;br&gt; 0, 90, 180, 270&lt;p&gt; &lt;p&gt;This key is available on all devices.&lt;p&gt; @see C" />
      <item value="generate" />
      <item value="generated" />
      <item value="generic" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="910" />
        <entry key="ENGLISH" value="911" />
        <entry key="ESTONIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="4" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1629769348430" />
  </component>
</application>