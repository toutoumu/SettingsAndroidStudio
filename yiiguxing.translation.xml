<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="566" />
    <option name="newTranslationDialogY" value="382" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="velocity" />
      <item value="shrink Towards" />
      <item value="Tween Spec" />
      <item value="duration Millis" />
      <item value="PROVICE" />
      <item value="Lots" />
      <item value="Prking Item" />
      <item value="隐私政策" />
      <item value="Combines cells with adaptive number of rows or columns. It will try to position as many rows or columns as possible on the condition that every cell has at least [minSize] space and all extra space distributed evenly. For example, for the vertical [LazyVerticalGrid] Adaptive(20.dp) would mean that there will be as many columns as possible and every column will be at least 20.dp and all the columns will have equal width. If the screen is 88.dp wide then there will be 4 columns 22.dp each." />
      <item value="An effect for handling presses of the system back button. Calling this in your composable adds the given lambda to the [OnBackPressedDispatcher] of the [LocalOnBackPressedDispatcherOwner]. If this is called by nested composables, if enabled, the inner most composable will consume the call to system back and invoke its lambda. The call will continue to propagate up until it finds an enabled BackHandler. @sample androidx.activity.compose.samples.BackHandler @param enabled if this BackHandler should be enabled @param onBack the action invoked by pressing the system back" />
      <item value="Caches the [PagingData] such that any downstream collection from this flow will share the same [PagingData]. The flow is kept active as long as the given [scope] is active. To avoid leaks, make sure to use a [scope] that is already managed (like a ViewModel scope) or manually cancel it when you don't need paging anymore. A common use case for this caching is to cache [PagingData] in a ViewModel. This can ensure that, upon configuration change (e.g. rotation), then new Activity will receive the existing data immediately rather than fetching it from scratch. Calling [cachedIn] is required to allow calling [submitData][androidx.paging.AsyncPagingDataAdapter] on the same instance of [PagingData] emitted by [Pager] or any of its transformed derivatives, as reloading data from scratch on the same generation of [PagingData] is an unsupported operation. Note that this does not turn the `Flow&lt;PagingData&gt;` into a hot stream. It won't execute any unnecessary code unless it is being collected." />
      <item value="repository" />
      <item value="coroutine" />
      <item value="Onboarding" />
      <item value="Tell Compose runtime that this object will not change so it can perform optimizations" />
      <item value="This app draws behind the system bars, so we want to handle fitting system windows" />
      <item value="expect" />
      <item value="用户协议" />
      <item value="Remember the value produced by [init]. It behaves similarly to [remember], but the stored value will survive the activity or process recreation using the saved instance state mechanism (for example it happens when the screen is rotated in the Android application). @sample androidx.compose.runtime.saveable.samples.RememberSaveable If you use it with types which can be stored inside the Bundle then it will be saved and restored automatically using [autoSaver], otherwise you will need to provide a custom [Saver] implementation via the [saver] param. @sample androidx.compose.runtime.saveable.samples.RememberSaveableCustomSaver You can use it with a value stored inside [androidx.compose.runtime.mutableStateOf]. @sample androidx.compose.runtime.saveable.samples.RememberSaveableWithMutableState If the value inside the MutableState can be stored inside the Bundle it would be saved and restored automatically, otherwise you will need to provide a custom [Saver] implementation via an overload with which has `stateSaver` param. @sample androidx.compose.runtime.saveable.samples.RememberSaveableWithMutableStateAndCustomSaver @param inputs A set of inputs such that, when any of them have changed, will cause the state to reset and [init] to be rerun @param saver The [Saver] object which defines how the state is saved and restored. @param key An optional key to be used as a key for the saved value. If not provided we use the automatically generated by the Compose runtime which is unique for the every exact code location in the composition tree @param init A factory function to create the initial value of this state" />
      <item value="Snapshot" />
      <item value="Return a new [MutableState] initialized with the passed in [value] The MutableState class is a single value holder whose reads and writes are observed by Compose. Additionally, writes to it are transacted as part of the [Snapshot] system. @param value the initial value for the [MutableState] @param policy a policy to controls how changes are handled in mutable snapshots." />
      <item value="enable Placeholders" />
      <item value="UNSPLASH STARTING PAGE INDEX" />
      <item value="Add content padding so that the content can be scrolled (y-axis) below the status bar + app bar" />
      <item value="reverse Layout" />
      <item value="Use statusBarsPadding() to move the app bar content below the status bar" />
      <item value="Use navigationBarsWithImePadding(), to move the input panel above both the navigation bar, and on-screen keyboard (IME)" />
      <item value="SemanticsPropertyReceiver is the scope provided by semantics {} blocks, letting you set keyvalue pairs primarily via extension functions." />
      <item value="keyboard Shown Property" />
      <item value="content Description" />
      <item value="semantics" />
      <item value="[CompositionLocalProvider] binds values to [ProvidableCompositionLocal] keys. Reading the [CompositionLocal] using [CompositionLocal.current] will return the value provided in [CompositionLocalProvider]'s [values] parameter for all composable functions called directly or indirectly in the [content] lambda." />
      <item value="annotation" />
      <item value="Mutable Transition State" />
      <item value="Opt-in to experiment animated insets support" />
      <item value="Composition Local Provider" />
      <item value="Create a ViewWindowInsetObserver using this view, and call start() to start listening now. The WindowInsets instance is returned, allowing us to provide it to AmbientWindowInsets in our content below." />
      <item value="Circular Reveal" />
      <item value="Workaround for simplicity" />
      <item value="Turn off the decor fitting system windows, which allows us to handle insets, including IME animations" />
      <item value="Prescription Drug Audit Details Fragment" />
      <item value="Have the content fill (possibly only partially) the [Constraints.maxWidth] of the incoming measurement constraints, by setting the [minimum width][Constraints.minWidth] and the [maximum width][Constraints.maxWidth] to be equal to the [maximum width][Constraints.maxWidth] multiplied by [fraction]. Note that, by default, the [fraction] is 1, so the modifier will make the content fill the whole available width. If the incoming maximum width is [Constraints.Infinity] this modifier will have no effect." />
      <item value="determine" />
      <item value="Coroutine Scope" />
      <item value="immediate" />
      <item value="Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a [Job]. The coroutine is cancelled when the resulting job is [cancelled][Job.cancel]. The coroutine context is inherited from a [CoroutineScope]. Additional context elements can be specified with [context] argument. If the context does not have any dispatcher nor any other [ContinuationInterceptor], then [Dispatchers.Default] is used. The parent job is inherited from a [CoroutineScope] as well, but it can also be overridden with a corresponding [context] element. By default, the coroutine is immediately scheduled for execution. Other start options can be specified via `start` parameter. See [CoroutineStart] for details. An optional [start] parameter can be set to [CoroutineStart.LAZY] to start coroutine _lazily_. In this case, the coroutine [Job] is created in _new_ state. It can be explicitly started with [start][Job.start] function and will be started implicitly on the first invocation of [join][Job.join]. Uncaught exceptions in this coroutine cancel the parent job in the context by default (unless [CoroutineExceptionHandler] is explicitly specified), which means that when `launch` is used with the context of another coroutine, then any uncaught exception leads to the cancellation of the parent coroutine. See [newCoroutineContext] for a description of debugging facilities that are available for a newly created coroutine. @param context additional to [CoroutineScope.coroutineContext] context of the coroutine. @param start coroutine start option. The default value is [CoroutineStart.DEFAULT]. @param block the coroutine code which will be invoked in the context of the provided scope." />
      <item value="pass Audit" />
      <item value="pass After Sale" />
      <item value="get Logistics Info" />
      <item value="trello" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="893" />
        <entry key="ENGLISH" value="894" />
        <entry key="ESTONIAN" value="1" />
        <entry key="AFRIKAANS" value="1" />
        <entry key="DANISH" value="4" />
        <entry key="GERMAN" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="DUTCH" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="LATIN" value="2" />
        <entry key="ROMANIAN" value="1" />
        <entry key="BENGALI" value="2" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="ITALIAN" value="1" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1630978642775" />
  </component>
</application>